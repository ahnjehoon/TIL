- JVM(Java Virtual Machine)의 구조는 크게 다음과 같은 주요 컴포넌트로 구성됨

## 클래스 로더 (Class Loader)

- 클래스 로더는 컴파일된 자바 바이트코드(.class 파일)를 
  런타임 데이터 영역에 로드하는 역할을 함
- 이 과정에서 클래스 파일을 읽고 분석하여 메모리에 적재함

## 런타임 데이터 영역 (Runtime Data Area)

- JVM의 메모리 영역으로, 다음과 같은 주요 부분으로 나뉨
  
  ### 메소드 영역 (Method Area)
  
  - 클래스 수준의 정보(클래스 이름, 부모 클래스 이름, 메소드, 변수 등)가 저장됨
  
  - 모든 스레드가 공유하는 영역임
    
    ### 힙 영역 (Heap Area)
  
  - 객체와 인스턴스 변수가 저장되는 공간임
  
  - 가비지 컬렉션의 대상이 되는 영역이기도 함
    
    ### 스택 영역 (Stack Area)
  
  - 각 스레드마다 별도로 생성됨
  
  - 메소드 호출 시 생성되는 지역 변수, 매개변수, 리턴 값 등이 저장됨
    
    ### PC 레지스터 (Program Counter Register)
  
  - 현재 실행 중인 명령의 주소를 가리키는 포인터가 저장됨
    
    ### 네이티브 메소드 스택 (Native Method Stack)
  
  - 자바 외의 언어로 작성된 네이티브 코드를 위한 스택임

## 실행 엔진 (Execution Engine)

- 바이트코드를 실행하는 역할을 담당하며, 다음과 같은 주요 부분으로 나뉨
  
  ### 인터프리터 (Interpreter)
  
  - 바이트코드를 한 줄씩 해석하고 실행함
    
    ### JIT 컴파일러 (Just-In-Time Compiler)
  
  - 반복적으로 실행되는 코드를 발견하면 
    해당 부분을 네이티브 코드로 변환하여 실행 속도를 향상시킴
    
    ### 가비지 컬렉터 (Garbage Collector)
  
  - 더 이상 사용되지 않는 객체를 자동으로 메모리에서 제거하는 역할을 함

---

- JVM은 이러한 구조를 통해 자바 프로그램을 실행하고 관리함.
- 클래스 로더가 바이트코드를 로드하면, 실행 엔진이 이를 해석하고 실행함.
- 이 과정에서 런타임 데이터 영역의 각 부분이 필요한 데이터를 저장하고 관리하며, 
  가비지 컬렉터가 메모리를 자동으로 관리함
- 이러한 구조 덕분에 자바는 플랫폼 독립성을 유지하면서도 효율적인 실행이 가능함.

---

## Heap Memory 와 Native Memory 의 차이

- ~~Metaspace 는 운영체제의 네이티브 메모리를 사용한다고 봄~~

- ~~근데 JVM 의 모든 메모리 영역은 JVM 의 관리 아래에 있는데 이게 뭔 소린가 싶어서 찾아봄~~

- Native Memory 는 OS 에서 Memory 를 동적으로 할당받아 사용함
  
  - 아니 Heap 이나 Native 나 OS 에서 할당받지 그럼 어떻게 할당받음? 이라는 의문이 있었음
  - 결론은 둘 다 JVM 이 OS 에서 할당받는 Memory 임
  - 근데 관리 방식과 목적이 다름

### Heap Memory

- 객체를 저장하기 위해 사용되는 Memory
- 객체가 생성될 때마다 사용됨
- GC 가 주로 관리하며, 동적으로 증가할 수 있지만 축소되는 것은 제한적임
- 주요 특징
  - OS 에서 할당
    - JVM 이 시작할 때 OS 에서 고정된 크기로 할당 받음
    - -Xms(초기 크기) -Xmx(최대 크기) 로 설정할 수 있음
  - 객체 저장 공간
    - new 키워드로 생성된 모든 객체는 Heap Memory 에 저장됨
    - 런타임에 생성된 동적 데이터를 저장하는 주요 저장소임
  - GC 관리
    - Heap Memory 영역은 GC 에 의해 관리됨
    - 더 이상 참조되지 않는 객체는 GC 에 의해 할당 해제되고 여유 공간을 확보함
  - 확장과 축소
    - 필요에 따라 -Xmx(최대 크기) 까지 확장될 수 있음
      Heap Memory 가 가득 차면 OS 에서 메모리를 할당받아 확장함
    - 일반적으로 한번 확장되면 축소되지 않음
      Heap Memory 의 크기가 줄어들 경우 메모리 재할당에 의한 성능저하가 발생할 수 있어서 JVM 성능을 위한 결정이라고 함

### Native Memory

- JVM 의 여러 컴포넌트가 필요로 하는 메모리를 관리하기 위해 사용됨
- Metaspace, JIT 컴파일 코드, 네이티브 코드 등을 관리하기 위해 사용됨
- 주요 특징
  - OS 에서 직접 할당
    - 필요할 때마다 OS 에서 동적으로 할당됨
    - Heap Memory 나 Native Memory 둘다 OS 에서 할당받지만
      축소과 확장의 유연성에서 차이가 있음
  - Metaspace
    - Java 8 부터 도입됨
    - 클래스 구조, 메서드, 필드 정보와 같은 메타데이터를 저장할 때 사용함
  - JNI(Java Native Interface)
    - Native Code(ex: C/C++) 와 인터페이스 할 때 사용함
  - JIT(Just In Time) 컴파일
    - 컴파일러가 바이트 코드를 네이티브 코드로 변환후 저장할 때 사용함
  - 확장과 축소
    - 필요에 따라 OS 에서 추가 메모리를 할당받거나 반환함
    - Heap Memory 보다 유연하게 관리됨
  - GC 의 영향이 적음
    - 일반적인 GC 사이클에서는 정리되지 않음
    - Metaspace 정도만 Major GC 에서 클래스 언로딩이 발생할때 영향을 받음