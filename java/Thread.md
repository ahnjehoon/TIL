- 일반적으로 Java에서 Thread를 생성하고 시작하는 경우 OS 수준에서 스레드가 생성됨

---

## Thread 구현 방식

### Native Thread
- 현대 JVM은 운영체제의 네이티브 스레드 라이브러리를 사용하여 스레드를 관리함
- Thread 객체를 생성하고 start()를 호출하면 OS에서 실제 스레드가 생성됨
- 자원 할당, 스케줄링 등은 운영체제가 담당함
### Green Thread
- 초기의 JVM은 그린 스레드라고 불리는 사용자 수준 스레드를 사용함
- 그린 스레드는 운영체제와 무관하게 JVM 내부에서 스케줄링되는 스레드였음
- 이 방식은 멀티코어 CPU를 효과적으로 활용할 수 없기 때문에 요즘엔 안씀
### Virtual Thread
- 19에서 소개되고 21부터 도입
- 기존의 스레드는 OS의 네이티브 스레드와 1:1로 매핑됨
- OS와 독립적으로 JVM에서 관리되며 실행될 때 몇 개의 네이티브 스레드에 매핑되어 실행됨
- work stealing 알고리즘을 사용하여 네이티브 스레드를 효과적으로 활용함

---

## Lifecycle
- 스레드는 여러 가지 상태를 가짐
- 이러한 상태들은 스레드의 생명주기를 이루고 있음
1. NEW (새로 생성됨)
2. RUNNABLE (실행 가능 상태)
3. BLOCKED (차단됨)\
4. WAITING (대기 상태)
5. TIMED_WAITING (시간 제한 대기 상태)
6. TERMINATED (종료됨)
### NEW
- 스레드 객체가 생성되었지만 아직 실행되지 않은 상태
- JVM의 힙 영역에 스레드 객체가 생성되어 저장
### RUNNABLE
- start() 메서드가 호출되면 스레드는 RUNNABLE 상태로 전환됨
- JVM은 해당 스레드를 운영체제에서 스케줄링할 준비를 함
- JVM은 스레드마다 스택 영역에 메모리를 할당함
- 스택 영역에는 각 스레드의 메소드 호출, 로컬 변수, 메소드 매개변수 등이 저장됨
- PC 레지스터도 각 스레드마다 고유하게 할당되어 현재 실행되고 있는 명령의 주소를 가리킴
### BLOCKED
- 스레드가 동기화 블록이나 모니터 락(monitor lock)을 획득하지 못해서 대기하고 있는 상태
### WAITING
- 스레드가 특정 조건이 만족될 때까지 무기한 대기하는 상태
- 다른 스레드의 알림(notification)을 받을 때까지 기다림
- 명시적인 신호가 없으면 다시 실행 상태로 전환되지 않음
### TIMED_WAITING
- 스레드가 특정 시간 동안 대기하는 상태
- 특정 시간이 지나면 스레드는 자동으로 RUNNABLE 상태로 돌아옴
### TERMINATED
- 스레드가 실행을 종료한 상태
- 스레드가 정상적으로 완료되거나 예외가 발생하여 종료된 경우 TERMINATED 상태가 됨
- 종료된 스레드는 다시 실행될 수 없음
- 종료된 스레드를 start() 메서드로 재실행하려고 하면 IllegalThreadStateException이 발생함

---

### work stealing 알고리즘
- 동시성 프로그래밍에서 작업을 효율적으로 분배하고 처리하기 위해 사용되는 스케줄링 기술
- 여러 개의 작업 스레드가 작업 큐에서 일을 가져와 수행할 때
  일부 스레드가 유휴 상태에 빠지지 않도록 하기 위해 고안됨