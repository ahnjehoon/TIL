- JAVA 의 Thread 는 처음 출시부터 JAVA 언어의 중요 구성 요소였음
- 시간이 지남에 따라 Thread 와 관련된 기능이 발전해옴
- 스레드 생성 시 각 스레드는 고유한 스택 메모리와 관련된 자원을 할당받음
- 스레드의 스택 크기는 플랫폼에 따라 다르지만 1~2MB 정도임
- 스택 메모리 할당은 OS 의 Native Memory 와 직접 연관되고 메모리를 확보하는 과정은 비용이 높은 과정임
- JVM 은 스레드를 관리하기 위해 스레드 객체를 생성하고 스레드의 상태, 우선순위, 이름 등 다양한 속성을 초기화 하는데 힙 메모리와 메소드 영역을 사용함
- 스레드는 JVM 에 의해 생성되지만, 관리와 실행은 OS 의 스레드 관리 시스템에 의해 이루어짐
    - 스레드가 생성되면 OS 커널 수준에서 실행 컨텍스트, 스케줄링 정보 등 여러자원이 할당됨
    - 스레드마다 커널 리소스를 할당하는 과정은 매우 복잡하고 시간이 소요되는 작업임
- 스레드가 실행중일 때 다른 스레드로 전환되는 과정은 `컨텍스트 스위칭(Context Switching)` 이라 하며 이 과정에서도 많은 비용이 발생함
    - 현재 실행 중인 스레드의 상태(레지스터 값 등)를 저장하고 새로 실행 될 스레드의 상태를 복원해야함
    - 위와 같은 과정은 CPU 사이클을 상당 부분 소모함
    - 또한 스레드 전환시 CPU 캐시 메모리에 저장된 내용이 무효화 될 수 있어 메모리 접근 속도가 느려지므로 시스템 성능이 저하될 수 있음

## Java 1.0 - 1996

### Thread 클래스

- java.lang.Thread 클래스로 스레드를 만들고 관리할 수 있었음
- JVM을 통해 플랫폼 독립적인 방식으로 병렬 처리를 가능하게 함
- 실제로는 JVM이 각 운영 체제의 스레드 메커니즘을 활용하여 스레드를 구현함

### Runnable 인터페이스

- 스레드가 실행할 로직을 정의하는 데 사용됨
- Runnable 을 사용하면 스레드의 동작과 실제 작업을 분리하여 구현할 수 있어 코드의 재사용성을 높이고 다중 상속의 제약을 우회할 수 있음

## Java 1.2 - 1998

- ThreadGroup 을 통한 스레드 관리기능이 강화됨
- 여러 스레드를 함께 제어하거나 모니터링할 수 있는 유연성이 향상됨

## Java 5 - 2004

- 멀티스레딩과 동시성 프로그래밍의 개발 편의성을 위해 `java.util.concurrent` 패키지가 추가됨
- 이 패키지는 멀티스레드 프로그래밍을 더 효율적으로 관리하고, 동시성 문제를 줄일 수 있는 다양한 유틸리티 클래스를 포함하고 있음
- Thread 관리와 관련하여 성능과 개발의 편의성을 크게 개선함.

### Executor Framework

- 직접 스레드 객체를 생성하지 않고 Executor 에게 작업을 위임해서 실행하게 함
  즉, 스레드 생성 및 실행을 추상화 함
- Executor
    - 스레드 실행을 단순히 관리하는 방법을 제공함
    - 스레드 풀을 사용하여 효율적으로 스레드를 재사용할 수 있음
- ExecutorService
    - Executor의 확장판으로 스레드를 관리하는 더 많은 기능을 제공함
    - 스레드를 종료시키거나, 특정 작업 완료를 기다리는 등의 기능을 제공함
- ScheduledExecutorService
    - 작업을 주기적으로 실행하거나 특정 시간에 실행하도록 스케줄링하는 기능을 제공함
- ThreadPool
    - 미리 일정 개수의 스레드를 생성하여 작업을 처리할 준비가 된 상태로 대기하는 방식
    - 스레드를 사용하고 반납하는 방식으로 스레드를 재사용 하여 매번 새로 생성하는 오버헤드비용을 줄일 수 있음
    - ExecutorService 에서는 주로 ThreadPoolExecutor 가 대표적인 스레드 풀 구현체임
    - 주요 스레드 풀 종류는 다음과 같음
        - FixedThreadPool: 고정된 수의 스레드를 가진 스레드 풀
        - CachedTreadPool: 필요에 따라 새로운 스레드를 생성하고 유휴 상태의 스레드는 재사용함
        - SingleThreadExecutor: 하나의 스레드로 작업을 순차적으로 처리하는 스레드 풀
        - ScheduledThreadPool: 특정 시간에 작업을 실행하는 스레드풀

### Future

- 비동기 작업 결과 관리
    - 스레드 작업의 비동기 결과를 추적하고 관리할 수 있는 기능을 제공함
    - 스레드가 작업을 완료할 때까지 기다리거나, 결과를 가져올 수 있음
- 취소 기능
    - 실행 중인 작업을 취소할 수 있음
    - 자원이 한정된 시스템에서 불필요한 작업을 제거하는 데 유용함

### Callable

- Runnable 과 유사하지만 기능이 확장된 인터페이스임
- 스레드 작업 결과 반환
- 예외 처리 가능

### ReentrantLock

- synchronized 키워드 대신 사용할 수 있는 새로운 잠금(Lock) 메커니즘으로 ReentrantLock이 도입됨
- 동일한 스레드가 여러 번 잠금을 걸 수 있는 기능을 제공함
- 잠금과 해제를 명시적으로 제어할 수 있어, 더 정교하게 동시성 문제를 처리할 수 있음

### Condition

- 특정 조건을 기다리거나 조건이 만족되면 스레드를 깨우기 위해 사용됨
- Object 클래스의 wait() 및 notify()을 사용하는 경우 기본적으로 하나의 잠금에서만 특정 조건을 기다리거나 신호를 보내는 것이 가능함
- Condition 은 여러 조건을 다룰 수 있고 각각의 조건에 대해 신호를 주고받을 수 있어서 다수의 스레드가 복잡하게 연관된 상황에서 동기화 문제처리에 도움을 줌

### BlockingQueue

- 생산자-소비자 패턴에서 유용한 기능을 제공함
- 스레드가 안전하게 큐에 아이템을 넣고 꺼낼 수 있도록 함
- 큐가 비어 있거나 가득 차 있는 경우, 자동으로 대기하거나 계속 시도하게 되어 복잡한 동기화를 쉽게 처리할 수 있음

## Java 7 - 2011

- 병렬 작업을 처리하기 위해 ForkJoinPool 을 도입함

### ForkJoinPool

- 큰 작업을 작은 작업으로 나누어 병렬로 처리하는 방식을 지원함
- 멀티코어 환경에서 성능을 크게 개선할 수 있음

## Java 8 - 2014

- Stream API 가 도입됨
- Stream 내부 parallelStream 은 내부적으로 스레드를 사용하지만 개발자는 복잡한 스레드 관리 없이 병렬처리를 할 수 있음

## Java 9 - 2017

- CompletableFuture 가 비동기 작업을 더 쉽게 처리할 수 있도록 개선됨
- 비동기 데이터 흐름을 관리하기 위한 Flow API 가 도입됨

### CompletableFuture

- 반응형(reactive) 스타일의 비동기 작업을 체이닝하고 처리할 수 있도록 개선됨
- 여러 작업의 완료를 기다리거나 작업 결과를 체이닝하는 것이 더욱 직관적이 되었음

### Flow API

- 생산자-소비자 관계에서 비동기 데이터 처리를 더욱 효율적으로 관리할 수 있게 해줌
- Publisher, Subscriber, Subscription, Processor의 네 가지 주요 구성 요소로 이루어져 있음

## Java 21

- 기존의 운영 체제 수준의 스레드와는 달리, JVM에서 관리하는 경량 스레드인 Virtual Thread 가 도입됨

### Virtual Thread

- 기존의 스레드는 운영 체제와 밀접하게 연동되어 있어 생성과 관리에 많은 리소스가 소모되었음
- Virtual Threads는 이와 달리 JVM 내에서 직접 관리되어 생성, 스위칭 및 종료의 비용이 훨씬 낮음
- 수십만 개의 Virtual Threads를 생성해도 리소스 부담이 크지 않기 때문에, 많은 동시성 작업을 수행하는 경우에도 성능 저하가 적음
- 네트워크 요청처럼 많은 수의 독립적이고 짧은 작업이 있을 때 유리함 대규모 병렬 처리가 필요한 서버 애플리케이션에서 좋은 성능을 보여줄듯