- ORM 프레임워크로, JPA(Java Persistence API)의 구현체
- 주요 특징
	- 객체 관계 매핑을 통한 SQL 자동 생성
	- 데이터베이스 독립성
	- 영속성 관리
		- 영속성 컨텍스트
		- 더티 체킹
		- 지연/즉시 로딩
	- 캐시
		- 1/2차 캐싱
		- 쿼리 캐싱
		- Statement 캐싱
## ORM(Object Relational Mapping)
- 객체 지향 패러다임과 관계형 데이터베이스 패러다임간의 불일치를 해결하기 위한 기술
	- 패러다임 불일치:
	  객체는 참조를 통해 관계를 표현하지만
	  데이터베이스는 외래 키를 통해 관계를 표현함
- 객체 모델과 관계형 모델간의 차이를 자동으로 매핑하여 개발자가 SQL을 직접 작성하지 않고 객체지향적으로 개발할 수 있게 함

## 데이터베이스 엔티티 vs Hibernate 엔티티
- 데이터베이스 엔티티
	- 테이블에 해당하는 개념
	- 실제 데이터가 저장되는 물리적 단위
	- 컬럼들의 집합으로 구성
- Hibernate 엔티티
	- 실제 데이터베이스의 데이터를 Java 객체로 표현
	- Java 객체이면서 데이터베이스의 테이블과 매핑되는 객체
	- @Entity 어노테이션으로 정의
	- 비지니스 로직을 포함할 수 있음

## Session & SessionFactory
- 데이터베이스와 상호작용을 관리하는데 중요한 역할을 함
### Session
- CRUD 작업을 수행하는데 사용되는 객체
- Thread safe하지 않아서 각 스레드마다 새로운 세션을 생성해야 함
- Session은 1차 캐시로 사용되어 동일한 트랜잭션 내에서 반복적으로 사용되는 객체를 캐싱
### SessionFactory
- Session 객체를 생성하고 관리
- 어플리케이션에서 하나만 생성(Singleton)
- 초기화시 많은 리소스 사용
- 데이터베이스 설정, 매핑 정보 등을 캐싱하여 성능을 최적화하고, 비용이 많이 드는 리소스를 공유
### Session과 SessionFactory 차이점
- SessionFactory는 어플리케이션에서 하나만 생성됨
- Session은 각 트랜잭션마다 생성됨
- SessionFactory는 Thread Safe하지만 Session은 Thread Safe 하지 않음

## 영속성 컨텍스트
- 엔티티 객체를 관리하고 데이터베이스와의 동기화를 담당
- `Session` 객체에 의해 관리되고 엔티티 객체의 생명주기를 제어함
- 1차 캐시를 통해 데이터베이스 접근을 줄임
- 변경 감지를 통해 수정을 편리하게함
- 지연 로딩을 통해 필요한 시점에만 데이터를 가져올 수 있게 함
### 영속 상태(Persistent State)
- 엔티티가 영속성 컨텍스트에 의해 관리되고 있는 상태
- 엔티티의 변경 사항이 자동으로 데이터베이스에 반영됨
### 비영속 상태(Transient State)
- 영속성 컨텍스트에 포함되지 않는 엔티티
- 새로 생성된 엔티티는 영속성 컨텍스트에 추가되지 않으면 비영속 상태
### 준영속 상태(Detached State)
- 영속 상태였다가 영속성 컨텍스트에서 분리된 엔티티
- 데이터베이스의 변경 사항을 추적하지 않음
### 엔티티 상태 전이(State Transitions)
- 엔티티는 영속, 비영속, 준영속, 삭제 상태로 전이될 수 있음
- session.save(entity): 비영속 -> 영속
- session.update(entity): 준영속 -> 영속
- session.delete(entity): 영속 -> 삭제
- session.detach(entity): 영속 -> 준영속

## 변경 감지(Dirty Checking)
- 영속 상태의 엔티티가 변경되면 트랜잭션을 커밋할때 자동으로 변경사항을 데이터베이스에 반영
- 엔티티가 영속성 컨텍스트에 저장될 때 최초 상태를 스냅샷으로 저장
- 트랜잭션이 커밋되는 시점에 스냅샷과 현재 상태를 비교하여 
  변경된 부분이 있다면 자동으로 UPDATE 쿼리를 생성하여 실행
### 주의사항
- 성능 문제
	- 엔티티의 변경 사항을 자동으로 감지하기 때문에 불필요한 UPDATE 쿼리가 발생할 수 있음

## 캐시
- 데이터베이스 접근은 비용이 많이 드는 작업임
- 캐시 사용시 다음과 같은 이점이 있음
	- 데이터베이스 조회 횟수 감소
	- 데이터베이스 부하 감소
	- 위의 사유로 인한 어플리케이션 성능 향상
### 캐시 전략 분리 이유
- 트랜잭션 범위와 생명 주기
	- 1차 캐시는 트랜잭션 범위 내에서만 동작
	- 2차캐시는 어플리케이션 전체 범위에서 동작
- 동시성 처리
	- 1차 캐시는 트랜잭션별로 독립적으로 동작하여 동시성 문제가 없음
	- 2차 캐시는 여러 트랜잭션이 공유하므로 동시성을 고려하여 복사본을 반환하는 방식을 사용함
- 성능 최적화
	- 1차 캐시는 영속성 컨텍스트와 직접 연결되어 빠른 엔티티 접근을 제공
	- 2차 캐시는 데이터베이스 접근을 줄여 어플리케이션 성능을 향상시킴

### 1차 캐시(First Level Cache)
- 영속성 컨텍스트 내부에서 동작
- 트랜잭션 범위에서만 유효
- 특징
	- 동일 트랜잭션 내 반복 조회 성능 향상
	- 영속 엔티티 동일성 보장
	- 트랜잭션 격리 수준 보장
### 2차 캐시(Second Level Cache)
- 어플리케이션 전체에서 공유
- SessionFactory 수준에서 동작
- 선택적으로 적용 가능
### 캐시 전략
- READ_ONLY
	- 읽기 전용 데이터에 사용
	- 변경 불가능한 데이터에 적합
	- 높은 성능
- NONSTRICT_READ_WRITE
	- 읽기 작업이 많고 쓰기가 가끔 발생하는 경우
	- 데이터 일관성을 완벽하게 보장하지 않음
	- UPDATE시 캐시 삭제
- READ_WRITE
	- 읽기/쓰기가 모두 필요한 경우
	- 동시성 제어를 통한 일관성 보장
	- 약간의 성능 저하
- TRANSACTIONAL
	- JTA 환경(여러 리소스가 하나의 글로벌 트랜잭션으로 관리되는 분산 트랜잭션 환경)에서 사용
	- 가장 강력한 일관성 보장
	- 성능 비용이 가장 큼
### 주의사항
- 변경이 빈번한 데이터는 캐시 부적합
- 데이터 일관성과 성능 사이의 균형
- 보완 필요

## 프록시 객체(Proxy Object)와 지연 로딩(Lazy Loading)
- Hibernate는 데이터베이스에서 결과를 반환할때 프록시 객체(Proxy Object)를 사용함
- 실제 엔티티 객체가 필요한 순간까지 데이터베이스 쿼리를 지연시켜 성능을 최적화함
### 주의 사항
- `LazyInitializationException`
	- 프록시 객체가 초기화 되지 않은 상태에서 접근하려고 할때 오류가 발생할 수 있음
	- 이 문제를 방지하기 위해 트랜잭션 내에서 접근하거나 Hibernate.initialize() 메서드를 사용해 명시적으로 초기화 할 수 있음

## 주의사항
### N + 1 문제
- 부모 엔티티를 조회할 때 연관된 자식 엔티티를 하나씩 반복적으로 조회하는 성능 문제
- 해결방법 (데이터베이스 쿼리 횟수를 줄이고 성능을 향상시킬 수 있음)
	- Fetch Join: HQL이나 JPQL에서 `JOIN FETCH` 구문을 사용하여
	  부모와 자식 엔티티를 한번에 조회
	- `@BatchSize`: 연관된 엔티티를 일정 수만큼 한꺼번에 로딩

## 식별자(Identifier) 생성 전략
- 엔티티의 식별자는 @GeneratedValue 어노테이션을 통해 생성 전략을 정의할 수 있음
- 전략에 따라 식별자 생성 시점이 달라 질 수 있음
- `save` `persist`
### GenerationType.IDENTITY
- 데이터베이스가 직접 식별자를 생성하는 방식
- save
	- 즉시 데이터베이스에 INSERT 쿼리가 실행됨
	- 이 과정에서 데이터베이스가 식별자를 생성해서 반환함
- persist
	- 영속성 컨텍스트에 추가되지만 INSERT 쿼리를 실행하지 않음
	- 트랜잭션이 커밋될때까지 대기함
	- 식별자가 필요할 경우 중간에 flush() 필요
### GenerrationType.SEQUENCE
- 데이터베이스 시퀀스를 사용하여 식별자를 미리 할당
- save
	- 데이터베이스 시퀀스를 조회하여 식별자를 할당함
- persist
	- 
	


---

### JPA와 Hibernate 차이점
- JPA(Java Persistence API)는 자바 진영의 ORM 표준 명세
- Hibernate는 JPA 명세를 구현한 구현체
- JPA는 인터페이스이고, Hibernate는 이를 실제로 구현한 라이브러리
- 표준 명세가 필요한 이유
	- 벤더 독립성
		- 특정 구현체에 종속되지 않음
		- 다른 구현체로 교체 가능(예: Hibernate -> EclipseLink)
	- 표준화
		- 모든 ORM 구현테가 동일한 방식으로 동작
		- 코드 일관성 유지